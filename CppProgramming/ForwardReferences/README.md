# 移动语义和完美转发

移动语义和完美转发是`c++ 11`增加的新特性，通常用于模板编程。完美转发主要是为了修补移动语义引入的问题，理解移动语义与完美转发可以帮助我们写出更好的泛型代码。

## 移动语义

移动语义指将一块内存空间（变量的内存单元或临时对象的内存单元）的所有权从一个对象转移到另一个对象，避免了拷贝以提高运行效率。其实现的关键在于右值引用。

### 左值和右值

简单来说，可以通过`&`取地址的，有自己名字的变量为左值。反之，不能取地址，不具名的变量或表达式为右值。例如：

对于`int a = 3`，可以通过`&a`取其地址，那么`a`就是一个左值，而显然无法通过`&3`取`3`的地址，那么`3`就是一个右值。

### 右值引用

对于一个左值引用，我们通常用`T&`来表示。而对于一个右值引用，通常用`T&&`来表示。

左值引用和右值引用在含义上没有本质区别，都是对于一个变量或对象（右值为临时变量或对象）的引用，是左值还是右直取决于被引用的变量或对象本身。

另外，还需注意，引用的值类型和变量类型并不一致。无论左值引用还是右值引用，其本身均为左值。例如：

```cpp
void Func(int&) {
    cout << "左值"<< std::endl;
}

void Func(int&&) {
    cout << "右值"<< std::endl;
}

template<typename T>
void Example(T&& v) {
    Func(v);
}

int main()
{
    Example(1);
    return 0;
}
```

上述程序运行结果为左值。也就是说，实际上引用类型唯一的作用就是限制接受的类型，但无论是左值引用还是右值引用，其本身在使用时还是一个左值。

在`c++ 11`中右值又分为纯右值和将亡值，事实上两者在功能上极其相似，一般情况下不必刻意区分，在此不再赘述。

### 移动语义

在使用一个左值用于构造对象时，通常会调用拷贝构造函数或拷贝赋值运算符来拷贝资源。而在使用一个右值用于构造对象时，则会调用移动构造函数或移动赋值运算符来移动资源，从而避免拷贝，提高效率。我们可以通过`std::move`将一个左值转换为一个右值。

另外，对于移动构造函数，还需要注意一点，通常在移动构造函数中抛出异常是一件危险的事，若移动语义还未完成时一个异常被抛出，这可能会导致一些指针变为悬垂指针。因此在编写移动构造函数时，通常会使用`noexcept`关键字禁止抛出异常。

### ROV优化

在现代编译器中，`ROV (return value optimization)`技术对于某些情况下函数的返回值会进行优化，用移动语义代替拷贝或赋值以提高性能。例如：

```cpp
vector<int> ReturnVector()
{
    vector<int>tmp = { 1,2,3,4,5 };
    return tmp;
}

int main()
{
    vector<int> v = ReturnVector();
    return 0;
}
```

该段代码经过`ROV`优化后不会创建临时对象，返回值将通过移动语义的方式直接赋值。

## 完美转发

完美转发仅在模板编程中对函数性能有较高要求时才会使用，在了解完美转发前，先介绍两个概念：万能引用和引用折叠。

### 万能引用

在模板编程中的`T&&`类型在发生参数推导时不代表右值引用，而是万能引用。其既能接受左值也能接受右值，最终的数据类型由`T`经过推导后的实际类型与`&&`进行引用折叠后确定。

### 引用折叠

引用折叠的根本原因是为了解决模板参数推导后出现双重引用的情况。例如：

```cpp
template<typename T>
void Example(T&& ex) {}
```

对于`T`的类型，可能存在`T&`和`T&&`（左值引用和右值引用）两种情况。当其为一个左值引用时，`ex`的数据类型将被推导为`T& &&`，这是一个双重引用，无法通过编译。

因此提出了引用折叠，考虑如下几种情况：

```
左值-左值 T& &
左值-右值 T& &&
右值-左值 T&& &
右值-右值 T&& &&
```

对于以上四种情况，折叠规则为：

`任意引用为左值引用时，将被推导为左值；仅当两个都为右值引用时，将被推导为右值。`

即只有`右值-右值 T&& &&`情况下会被推导为右值引用，其他情况均视为左值引用。

### 完美转发

若在编程中希望参数能以原本的引用类型进行传递时，可以通过`c++`标准库提供的`std::forward`方法进行完美转发。以参数原本的类型进行转发，不会改变其类型。例如：

```cpp
void Func(int&) {
    cout << "左值";
}

void Func(int&&) {
    cout << "右值";
}

template<typename T>
void Example(T&& v) {
    Func(forward<T>(v));
}

int main()
{
    Example(1);
    return 0;
}
```

上述程序运行结果为右值。完美转发在传递过程中保持其左值或右值的属性不变。

以下提供一个简易的程序用于理解`std::forward`的实现原理：

```cpp
template<typename T>
T&& Forward(T&& f) {
    return static_cast<T&&>(f);
}
```

若`Forward<T>`中的`T`为左值，那么`T& &&`经过引用折叠后还是`T&`类型的左值引用，形参`f`将转换为`T&`的左值引用类型。

若`Forward<T>`中的`T`为右值，那么`T&& &&`经过引用折叠后还是`T&&`类型的右值引用，形参`f`将转换为`T&&`的右值引用类型。
