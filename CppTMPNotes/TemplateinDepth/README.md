# 4. Template in Depth

## 4.1 Template Arguments Deduction of Function Template
函数模板的实参推导发生在名字查找(Name Lookup)之后，重载决议(Overload Resolution)之前。如果函数模板实参推导失败，那么编译器不会直接报错，而是将这个模板从函数的重载集合中无声的删除。

```cpp
template <typename T, typename U> void foo(T, U) {} // #1
template <typename T> void foo(T, T) {}             // #2
void foo(float, int) {}                             // #3

foo(1, 1.0f);
```

在上面的例子中，`foo`有两个函数模板和一个普通函数，对#2的实参推导失败了，但并不会发生错误，编译器会匹配模板#1。我们简单阐述一下这个过程中发生了什么:
1. 首先，编译器看到了对函数`foo`的一个调用。
2. 编译器通过名字查找，找到所有名为`foo`的函数和函数模板，找到了#1，#2，#3.
3. 对每个函数模板，编译器尝试通过函数实参(1, 1.0f)来推断模板的实参。
- 对#1，T被推导为int，U被推导为float，没问题。
- 对#2，通过第一个参数推导T为int，通过第二个参数推导T为float，推导失败，#2被移除重载集。
4. 编译器对当前重载集(#1和#3)进行重载决议，#1被选中。
5. 编译器对#1进行替换(Substitution)以完成实例化。

## 4.2 Template Arguments Deduction of Class Template
类模板的实参推导与函数模板不同，当同时定义了主模板和模板特化时，实参推导只考虑主模板，模板特化不参与实参推导。如果主模板实参推导出错，那么编译器直接报错。

```cpp
template <typename T, typename U>
struct S { S(T a, U b) { std::cout << is_same_v<decltype(b), float> } };    // #1

template <typename T>
struct S<T, float> { S(T a, T b) { std::cout << is_same_v<decltype(b), float> } };  // #2

template <>
struct S<int, int> { S(int a, int b) { std::cout << is_same_v<decltype(b), float> } };  // #3

S s(1, 1.0f);
```

在上面的例子中，编译器通过主模板的构造函数推导出T=int，U=float，这个模板实参的最佳匹配结果是特化#2，所以最终调用的构造函数是#2实例化后的`S<int, float>::S(int, int)`，第二个实参`1.0f`被隐式转换为了int。而假设用特化#2去做模板实参推导的话，这个推导式失败的，这也反证了编译器并不是用模板特化推导实参的。我们简单阐述一下这里发生了什么:
1. 首先，编译器看到变量"s"的定义。
2. 编译器通过名字查找，找到名为"S"的类或类模板，这里应该只找到一个，否则会抛出类型重定义的错误。
3. 编译器找到了类模板S，对S的主模板，编译器尝试根据构造函数实参(1, 1.0f)推导模板实参，得到T=int，U=float。
4. 编译器根据模板实参去匹配最优的特化，匹配到#2.
5. 编译器对#2进行替换以完成实例化。

## 4.3 Make Choice between Primary Template and Its Specializations
在前面的例子中，我们已经简单阐述了编译器事如何在主模板和特化模板之间做出选择的。现在，我们来更加准确的描述这一过程。

在模板的实例化中，当所有模板实参都确定了以后，编译器就需要在模板的主模板和所有显式特化中选择一个来做替换，规则是:
1. 对每一个模板特化，先判定它能不能匹配该实例化。
2. 如果只有一个模板特化能匹配模板实参，那么就选择这个特化。
3. 如果有多个模板特化都能匹配模板实参，那么通过这些特化的偏序关系来决定哪个模板特化的特化程度更高，其中特化程度最高的将被选中。如果存在多个模板特化，它们的特化程度无法比较高低，那么编译器会报错，实例化失败。
4. 如果没有任何一个模板特化能匹配模板实参，那么主模板被选中。

## 4.4 Partial Ordering Rule
对于两个函数模板fa和f吧，怎么判定谁的特化程度更高呢？这个过程也是一个代入+推导的过程。用fa代入推导fb是指:

记fb的模板形参为T。假设fa的模板实参是U，那么fa的函数实参类型(记为A)就可以用U来表示出来。我们用A代入fb的函数形参列表(记为P)，并尝试由此推导fb的模板形参T，这里推导的意思就是尝试用U来表示T。

如果fa代入推导fb成功，并且用fb代入推导fa失败，那么我们称fa比fb的特化程度更高。这就是模板的偏序规则。

规则有点复杂，我们通过例子来理解:

```cpp
template <typename T> void foo(T);  // #1
template <typename T> void foo(T*); // #2
template <typename T> void foo(const T*);   // #3

const int* p;
foo(p);
```

首先，尝试用#2来代入推导#1，记#1的模板形参为T，并假设给#2传入一个实参U，那么#1和#2就被表示为这样两个函数模板:

```cpp
template <typename T> void foo(T);  // #1
template <typename T=U> void foo(U*);   // #2
```

我们将下面的函数实参U代入上面的函数形参，也就是将#1写为`template <typename T> void foo(T=U*)`，然后推导T，得出T=U，代入推导成功。

然后，我们尝试用#1来代入推导#2，记#2的模板形参为T，并给#1传入一个实参U，那么#1和#2就被表示为:

```cpp
template <typename T=U> void foo(U);    // #1
template <typename T> void foo(T*); // #2
```

然后将上面的函数实参U代入下面，将#2写为`template <typename T> void foo(T*=U)`，然后推导T，失败。得出结论：#2的特化程度比#1高。

这个规则之所以称为偏序规则，是因为函数模板的重载集是一个偏序集合，几黑元素之间的关系是偏序关系。也就是说，并不是任意两个函数模板都是可以比较的，有时候无法比较两个模板谁的特化程度更高，如果从fa代入推导fb成功，且从fb代入推导fa成功；或是从fa代入推导fb失败，且从fb代入推导fa失败，那么fa和fb就被认为是无法比较的，或者说特化程度是相同的。此时重载决议无法判定哪个的优先级更高，编译器抛出一个歧义错误。

## 4.5 Template Overloads vs Template Specializations
函数模板既可以重载，又可以特化，它们之间的关系是什么呢？特化会不会影响重载呢？

答案是函数模板的每个重载都是主模板，在重载决议的时候，只考虑非模板函数和函数模板的主模板，模板的特化不在重载集的范畴之内。并且对于一个函数调用，是先进行重载决议，确定使用哪个主模板，再考虑是否使用该模板的特化。例如下面哪个foo会被实例化？

```cpp
template <typename T> void foo(T);  // #1
template <> void foo(int*); // #2
template <typename T> void foo(T*); // #3

foo(new int(1));
```

答案是#3。编译器会在#1和#3中进行重载决议，#2只是#1的一个特化，不予考虑。重载决议选择了#3，而且#3也没有特化，那么就会实例化#3这个主模板。虽然看起来#2才是这次调用的一个完美匹配，但可惜，规则如此。

第二个例子，哪个foo会被实例化呢？

```cpp
template <typename T> void foo(T);  // #1
template <typename T> void foo(T*); // #3
template <> void foo(int*); // #2

foo(new int(1));
```

只是把#2和#3调换了位置，答案就变了。这次编译器会选择#2。因为调换了位置，#2变成了#3的一个特化了。这里我们看到，编译器在决定一个模板特化属于哪个主模板的时候，只会从它已经看见的主模板里选择。在第一个例子中，编译器在为#2寻找主模板的时候，还没看见#3，所以认为它是#1的特化。

第三个例子，哪个foo会被实例化呢？

```cpp
template <typename T> void foo(T);  // #1
template <> void foo(int*); // #2
template <typename T> void foo(T*); // #3
template <> void foo(int*); //#4

foo(new int(1));
```

没错，是#4。

最后，值得说明的是，为什么编译器在重载决议的时候不考虑特化呢？因为模板的特化并不引入一个名字。所以在名字查找的时候，模板特化就直接被忽略了，或者说是和主模板视为一体的，不是一个独立的名字。所以我们一定要注意，编译器是按步骤做事的，第一步，名字查找；第二步，实参推导；第三步，重载决议；第四步，选择特化；第五步，替换生成实例。

## 4.6 SFINAE
SFINAE的全称是: Substitution Failure Is Not An Error。替换失败不是一个错误。这可能是模板编程中最出名的规则了，我们将这句话拆为两部分理解:

1. Substitution Failure
- 替换失败是指，如果用实参替换了模板形参后，在模板立即上下文中的类型或表达式呈现非良结构，那么这种情形就称为替换失败。非良结构是指代码违背了语法或语义规则。立即上下文指在模板的声明里的内容。
2. Is Not An Error
- 在函数模板的实例化中，如果发生替换失败，那么这个函数模板就无声的从重载集中剔除，编译器继续尝试其他重载，而不是抛出一个错误。
- 在类，变量模板偏特化的实例中，如果发生替换失败，那么这个特化就从特化集中剔除，编译器继续尝试其他特化，而不是抛出一个错误。

要说明的是，如果每个重载(特化)都发生了替换失败，没有其他重载(特化)可用，那编译器还是会报错。

举个例子来进一步理解SFINAE:

```cpp
template <typename T>
typename T::value_type foo(T t){
    T::value_type i;
}

foo(1);
```

在这个实例化中，有三处发生了替换，一个是函数的返回值，一个是函数的形参列表，一个是函数内部的局部变量声明。在函数的返回值处，替换后构成了非良结构，因为int::value是一个非法的名字，但这在立即上下文内，所以是一个替换失败。在局部变量i的声明处，替换后也构成了非良结构，但这里不在立即上下文内，所以是一个硬错误。

第二个例子，用以说明SFINAE在函数模板重载中的作用:

```cpp
template <typename T> void foo(T) {};   // #1
template <typename T> void foo(T*) {};  // #2
template <typename T> T::value_type foo(T) {};  // #3

foo(1);
foo(new int(1));
foo<int&&>(1);
```

在`foo(1)`的实例化中，#3发生替换失败，从重载集中排除，重载决议在#1和#2中选择了#1。在`foo(new int (1))`的实例化中，#3发生替换失败，重载决议在#1和#2中选择#2。在`foo<int&&>(1)`中，#2和#3都发生了替换失败，重载决议选择了#1。

第三个例子，用以说明SFINAE在类模板偏特化中的作用:

```cpp
template <typename T, typename U> struct S {};  // #1
template <typename T> struct S<T, typenamte T::value_type> {};  // #2

S<int,int>();
S<true_type,bool>();
S<true_type,int>();
```

在`S<int, int>`的实例化中，#2发生替换失败，编译器选择主模板#1来实例化。在`S<true_type, bool>`的实例化中，没有发生替换失败，编译器选择#2。在`S<true_type, int>`的实例化中，没有发生替换失败，但根据匹配规则，#2不匹配，所以选择#1。

## 4.7 Review of Template Instantiation
最后，回顾一下整个实例化过程。当一个实例化发生时，编译器:
1. 进行名字查找，找到所有匹配该名字的模板
- 如果是函数模板，可能会找到一个或多个重载
- 如果是类，变量模板，应找到唯一的主模板，否则抛出重定义错误
2. 确定所有的模板实参，需要推导的，通过主模板来推导
- 对函数模板，如果推导失败，那么这个模板从重载集中剔除
- 对类，变量模板，如果推导失败，抛出错误
3. 对函数模板，进行重载决议，决议时只考虑主模板
- 偏序规则和SFINAGE在此发挥作用
4. 对确定的主模板和它的特化，选择最匹配的那个
- 对类，变量模板，因为存在偏特化，偏序规则和SFINAE在此发挥作用
- 对函数模板，只有全特化，直接匹配就行
5. 对最终选定的主模版或特化进行替换，生成真实代码
