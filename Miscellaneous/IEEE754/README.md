# IEEE 754 二进制浮点数计算

IEEE 754标准是一种用于浮点数表示和运算的标准，定义了浮点数的编码格式、舍入规则以及基本的算数运算规则，提供一种可移植和一致性的方式来表示和处理浮点数。

## 浮点数存储方式

按照IEEE 754标准，浮点数的存储格式由符号、阶码、尾数三部分组成。

| 类型     | 符号 | 阶码 | 尾数 | 总位数 | 偏置值   |
|--------|----|----|----|-----|-------|
| float  | 1  | 8  | 23 | 32  | 127   |
| double | 1  | 11 | 52 | 64  | 1023  |

- 符号位S：符号位为 0 表示浮点数为正数，为 1 表示浮点数为负数。
- 阶码E：表示浮点数被二进制表示法后的指数，用移码表示。
- 尾数M：表示浮点数被二进制表示法后的尾数，因为其要求小数点前一位数必须为 1，所以尾数中实际隐含了最高位的 1，例如尾数为 M，实际还原时相当于 1.M。

也就是说，IEEE 754浮点数表示法，本质上就是对浮点数采用科学计数法表示，将其表示为：

$$x = (-1)^S \cdot (1.M) \cdot 2^E$$

接下来，我们先介绍移码的含义和作用。

### 补码和移码

#### 补码

在讨论移码前，我们先来了解什么是补码。众所周知，计算机以二进制补码的形式存储整数，最高位是符号位，0 表示正数，1 表示负数。

正数的补码就是其本身，而负数的补码则为数字位取反后再加一。例如 +3，其二进制补码为 0011，而 -3，其二进制补码为 1101。

为什么不直接用符号位的形式表示负数，而是使用补码的形式呢？

只改变符号位的表示方式叫原码，看起来很简单，但在进行加减计算时很麻烦。

例如，只改变符号位的 +3 为 0011，-3 为 1011，其相加显然应该为 0，但结果却为 0011 + 1011 = 1110，这并不符合直觉。

而如果使用补码计算，其结果为 0011 + 1101 = 10000，取低四位结果是 0000，是符合直觉的。

而且，如果只改变正负数的符号位，对于 0 就由两种表示形式，正 0（0000）和负 0（1000），这显然也是不好的。

#### 移码

移码本质上是为了便于比较两个二进制数的大小。其值是通过真值加偏置值得到的。偏置值往往取 $2^{n-1}$ ，其中 n 表示二进制位数。

为什么移码可以便于比较两个二进制数的大小呢？考虑以下例子：

假设使用 8 位二进制数表示一个有符号整数 -3，偏置值取 $2^{8-1}$ 为 128，则其原码为 1000 0011，补码为 1111 1101，移码为 0111 1101。

同样的，对于有符号整数 +3，其原码为 0000 0011，补码为 0000 0011，移码为 1000 0011。

对比 -3 和 +3，显然，其原码和补码因为符号位的存在，直接比较二进制数的结果是 $-3 > +3$，这不符合直觉。而移码通过偏置值，将其符号位取反，直接比较二进制数的结果则为 $+3 > -3$，是符合直觉的。

在对浮点数进行运算时，需要对阶码进行比较。（因为是用科学计数法表示的，运算时需要对指数做比较。）所以，在IEEE 754标准中，选用移码来表示阶码。

以 8 位二进制为例，为什么IEEE 754中使用的偏置值是 $2^{n-1}-1$ 而不是 $2^{n-1}$呢？目前没有找到官方的详细解释，以下是个人的理解。

因为在IEEE 754标准中，对浮点数分为三种状态，分别是规格数，非规格数，特殊数，我们将在下文中详细介绍这三种状态。在这里只需知道，对于阶码，标准中定义 0000 0000 为非规格数，1111 1111 为特殊数。

对于 8 位二进制无符号整数来说，其取值范围为 0 ~ 255，但因全 0 和全 1 组成的二进制数被IEEE 754标准保留，无法用于表示常规浮点数。所以，其取值范围为 1 ~ 254，对应 8 位二进制有符号整数来说，取值范围为 -126 ~ + 127。

而当取偏置值为 128 时，原值 + 127 的移码为 1111 1111，这超过了有效的表示范围；当取偏置值为 127 时，原值的 -127 的移码为 0000 0000，同样超过了有效的表示范围。

也就是说，偏置值取 128 或 127，决定了原值有效的表示范围将舍弃 +127 阶或 -127 阶。而对比两者，显然 $2^{-127}$ 阶更趋近于 0，而 $2^{127}$ 则能表示更大的范围，所以选择舍弃 -127 阶，保留 +127 阶，这样数据能表示的范围更大。因此，IEEE 754对于32位浮点数采用 127 作为偏置值，64位同理。
