# IEEE 754 二进制浮点数计算

IEEE 754标准是一种用于浮点数表示和运算的标准，定义了浮点数的编码格式、舍入规则以及基本的算数运算规则，提供一种可移植和一致性的方式来表示和处理浮点数。

## 浮点数存储方式

按照IEEE 754标准，浮点数的存储格式由符号、阶码、尾数三部分组成。

| 类型     | 符号 | 阶码 | 尾数 | 总位数 | 偏置值   |
|--------|----|----|----|-----|-------|
| float  | 1  | 8  | 23 | 32  | 127   |
| double | 1  | 11 | 52 | 64  | 1023  |

- 符号位：符号位为 0 表示浮点数为正数，为 1 表示浮点数为负数。
- 阶码：表示浮点数被二进制表示法后的指数，用移码表示。
- 尾数：表示浮点数被二进制表示法后的尾数，因为其要求小数点前一位数必须为 1，所以尾数中实际隐含了最高位的 1，例如尾数为 M，实际还原时相当于 1.M。

### 补码和移码

#### 补码

在讨论移码前，我们先来了解什么是补码。众所周知，计算机以二进制补码的形式存储整数，最高位是符号位，0 表示正数，1 表示负数。

正数的补码就是其本身，而负数的补码则为数字位取反后再加一。例如 +3，其二进制补码为 0011，而 -3，其二进制补码为 1101。

为什么不直接用符号位的形式表示负数，而是使用补码的形式呢？

只改变符号位的表示方式叫原码，看起来很简单，但在进行加减计算时很麻烦。

例如，只改变符号位的 +3 为 0011，-3 为 1011，其相加显然应该为 0，但结果却为 0011 + 1011 = 1110，这并不符合直觉。

而如果使用补码计算，其结果为 0011 + 1101 = 10000，取低四位结果是 0000，是符合直觉的。

而且，如果只改变正负数的符号位，对于 0 就由两种表示形式，正 0（0000）和负 0（1000），这显然也是不好的。

#### 移码