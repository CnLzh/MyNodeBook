# Thread Safe
线程安全是多线程编程中非常重要的概念。如何设计规范的方式以确保所有线程正常运行并操作共享数据结构，是不可避免的话题。

编写线程安全的类并不复杂，用同步原语(Synchronization Primitives)保护内部状态即可。但对象的生存周期不能由其自身的mutex来保护。如何避免对象析构时可能存在的竞态条件(Race Condition)是C++多线程编程面临的基本问题。

## 线程安全的定义
一个线程安全的类，应当满足以下三个条件：
- 多个线程同时访问，表现出正确的行为。
- 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何。
- 调用端代码无需额外的同步或协调动作。

根据这个定义，C++标准库里的大多数class都不是线程安全的，包括`std::string, std::vector, std::map`等，因为这些class通常需要外部加锁才能供多个线程同时访问。

## 避免死锁
假设线程A和线程B都需要两个互斥M1和M2时，若A持有M1，B持有M2，则A、B线程互相持有对方所需要的资源，互相等待对方释放资源，若线程不主动释放资源，则两个线程均无法继续执行，这就造成了死锁。因此，一个函数如果要锁住多个对象，为了保证始终按照相同顺序加锁(否则会死锁)，可以通过比较mutex对象的地址，始终先加锁地址较小的mutex。

## 对象的构造
对象构造的线程安全很简单，只要在构造期间不泄漏this指针，即：
- 不要在构造函数中注册任何回调
- 不要在构造函数中跨线程传递this给其他对象

因为构造函数执行期间，对象还没有完成初始化，如果this被泄漏给其他对象，那么别的线程可能访问这个半成品对象，会造成难以预料的后果。

即使在构造函数的最后一行也不要泄漏this，因为如果`class Foo`是一个基类，优先于派生类构造，那么执行完`Foo:Foo()`的最后一行代码后，还会继续执行派生类的构造函数，此时仍然不安全。

## 对象的析构
对象的析构，在单线程中只需要注意避免空悬指针和野指针。但在多线程环境中，存在了很多竞态条件。虽然可以通过mutex保护临界资源，但析构函数会破坏这一条件，它会把mutex成员变量销毁掉。

### 数据成员的mutex不能保护析构
假设如下：
1. 线程A执行X的析构函数，持有互斥锁，继续往下执行析构。
2. 线程B此时访问X，被阻塞。

接下来将发生不可预料的后果。因为线程A会把互斥锁销毁，那么线程B可能永远阻塞下去，也可能进入临界区然后coredump，或者发生其他更糟糕的事。

由此可见，作为数据成员的mutex只能用于同步本类的其他数据成员的读写，不能保护安全的析构。因为mutex的生命周期最多和对象一样长，不能保护整个析构过程。而且，析构过程本来也不需要被保护，因为只有别的线程都访问不到这个对象，析构才是安全的。

### 线程安全的Observer

